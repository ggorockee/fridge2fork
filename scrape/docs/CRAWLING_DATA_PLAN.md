# Fridge2Fork 크롤링 및 데이터 설계 계획서

## 📋 프로젝트 개요

### 목표
만개의레시피 사이트에서 한식 레시피 데이터를 체계적으로 수집하여 Fridge2Fork 모바일 앱에 통합할 수 있는 형태로 가공하는 시스템 구축

### 핵심 요구사항
- **데이터 소스**: 만개의레시피 (HTML 스크래핑 기반)
- **타겟 앱**: Fridge2Fork (Flutter 멀티플랫폼)
- **데이터 규모**: 200,000+ 개 레시피 (전체 수집)
- **실행 주기**: 월간 또는 분기별 전체 수집
- **데이터 품질**: 높은 정확도와 일관성 보장

## 🏗️ Phase별 실행 계획

---

## Phase 1: 인프라 구축 및 데이터 수집 전략 (2-3주)

### 1.1 기술 스택 선정 및 환경 구축

#### 크롤링 도구 선택 기준
- **Playwright vs Selenium**: Playwright가 더 빠르고 안정적
- **성능 우선**: Selenium 대비 2-3배 빠른 실행 속도
- **메모리 효율성**: 더 적은 리소스 사용
- **JavaScript 렌더링**: 동적 콘텐츠 처리에 최적화

#### 권장 기술 스택
- **Playwright**: 브라우저 자동화 및 JavaScript 렌더링
- **BeautifulSoup4**: HTML 파싱
- **Requests**: HTTP 요청
- **AsyncIO**: 비동기 처리로 성능 향상

#### 데이터 저장소
- **Primary Database**: PostgreSQL (관계형 데이터 구조, ACID 트랜잭션)
- **Cache Layer**: Redis (세션 관리, 요청 캐싱, 실시간 모니터링)
- **File Storage**: PVC (Persistent Volume Claim) 또는 클라우드 스토리지

#### 개발 환경
- **Docker 컨테이너화**: Python 3.11, Chromium 브라우저, PostgreSQL 15, Redis 7
- **배치 처리**: 컨테이너 기반 월간/분기별 실행
- **안정성 우선**: 높은 배치 안정성과 오류 복구 시스템

### 1.2 데이터베이스 설계 및 성능 최적화

#### 아키텍처 선택 고려사항
- **Raw Python vs ORM**: 대용량 데이터 처리 시 Raw Python이 더 빠름
- **Alembic**: 스키마 마이그레이션 관리용
- **FastAPI**: REST API 제공용 (필요시)
- **속도 최적화**: 인덱스 생성 및 배치 삽입 최적화

#### Core Tables 설계
- **recipes**: 레시피 기본 정보 (source_id, title, description, category 등)
- **ingredients**: 재료 정보 (name, amount, normalized_name)
- **cooking_steps**: 조리 단계 (step_number, description, image_url)
- **recipe_images**: 이미지 정보 (image_url, local_path, file_size)

#### 성능 최적화 전략
- **인덱스 생성**: source_id, category, normalized_name 등 자주 검색되는 필드
- **배치 삽입**: 대량 데이터 처리 시 트랜잭션 최적화
- **파티셔닝**: 날짜별 또는 카테고리별 테이블 분할 고려

### 1.3 크롤링 규칙 및 에티켓 정의

#### 크롤링 정책
- **요청 간 지연시간**: 1.5초 (서버 부하 최소화)
- **동시 요청 수**: 3개 (안정성 우선)
- **재시도 횟수**: 3회 (네트워크 오류 대응)
- **요청 타임아웃**: 30초
- **User-Agent 로테이션**: 다양한 브라우저 시뮬레이션

### 1.4 샘플 데이터 크롤링

#### 배치 처리 방식
- **데이터수집**: 100개의 데이터만 일단 수집
- **데이터 뷰**: Database는 준비가 안되어있으니 pandas를 이용하여 데이터 정상 삽입확인,tail(), head() 메소드를 이용
- **실행 시간**: 넉넉한 시간 할당 (안정성 우선)

#### 법적 준수사항
- robots.txt 준수
- 이용약관 확인 및 준수
- 데이터 사용 목적 명시
- 개인정보 보호 규정 준수

---

## Phase 2: 핵심 데이터 수집 (4-6주)

### 2.1 레시피 목록 수집 전략

#### 배치 처리 방식
- **실행 주기**: 월간 또는 분기별 전체 수집
- **컨테이너 기반**: 지속적인 컨테이너 실행으로 안정성 확보
- **실행 시간**: 넉넉한 시간 할당 (안정성 우선)
- **배치 안정성**: 높은 안정성과 오류 복구 시스템 구축

#### 수집 대상
- **카테고리**: 한식, 중식, 일식, 양식, 분식, 간식, 음료, 베이킹, 반찬, 국/탕
- **페이지네이션**: 전체 페이지 순차 수집
- **레시피 ID 추출**: HTML 파싱을 통한 ID 수집
- **메타데이터**: 기본 정보 및 카테고리 분류

#### 예상 수집 규모
- **총 레시피 수**: 200,000+ 개
- **카테고리별 분포**: 한식 40%, 기타 60%
- **수집 주기**: 전체 수집 (분기별 변경 가능)
- **처리 시간**: 대용량 데이터 처리로 인한 장시간 실행

### 2.2 레시피 상세 정보 수집

#### 상세 페이지 스크래핑 전략
- **URL 패턴**: `https://www.10000recipe.com/recipe/{recipe_id}`
- **Playwright 활용**: JavaScript 렌더링 및 동적 콘텐츠 처리
- **데이터 추출**: 기본 정보, 재료, 조리 단계, 이미지, 메타데이터

#### 추출 대상 데이터
- **기본 정보**: 제목, 설명, 카테고리, 난이도, 조리시간, 인분
- **재료 정보**: 재료명, 양, 필수 여부 (CSS 셀렉터: `a[href*="javascript:viewMaterial"]`)
- **조리 단계**: 단계별 설명 및 이미지 (CSS 셀렉터: `.view_step > div`)
- **이미지**: 레시피 관련 모든 이미지 URL
- **메타데이터**: 평점, 리뷰 수, 작성자 정보

### 2.3 이미지 수집 및 처리 시스템

#### 이미지 처리 파이프라인
- **다운로드**: 레시피별 모든 이미지 다운로드
- **최적화**: 크기 조정 (최대 800x600), 품질 최적화 (JPEG 85%)
- **저장**: PVC 또는 클라우드 스토리지에 저장
- **메타데이터**: 파일 크기, 해상도 정보 저장

#### 성능 최적화
- **병렬 처리**: 다중 이미지 동시 다운로드
- **압축**: 메타데이터 제거 및 효율적인 압축
- **캐싱**: 중복 이미지 방지 시스템

---

## Phase 3: 데이터 정제 및 정규화 (3-4주)

### 3.1 재료명 표준화 시스템

#### 재료 정규화 전략
- **표준화 매핑**: 동일한 재료의 다양한 표현을 표준명으로 통일
- **예시 매핑**: "감자", "포테이토", "potato" → "감자"
- **불필요한 문자 제거**: 특수문자, 공백 정리
- **단위 정보 분리**: "감자 4개" → 재료: "감자", 양: "4", 단위: "개"

#### 재료 분류 체계
- **정육/계란**: 돼지고기, 소고기, 닭고기, 계란 등
- **수산물**: 생선, 새우, 게, 오징어 등
- **채소**: 양파, 마늘, 감자, 당근 등
- **장/양념/오일**: 된장, 고추장, 간장, 식용유 등

### 3.2 조리 단계 정리 및 표준화

#### 단계 표준화 프로세스
- **불필요한 텍스트 제거**: 광고, UI 요소 등 제거
- **단계별 설명 정리**: 명확하고 간결한 설명으로 변환
- **이미지 정보 연결**: 단계별 이미지 URL 매핑
- **순서 정렬**: 논리적인 조리 순서로 재배열

### 3.3 데이터 품질 관리 시스템

#### 검증 규칙
- **필수 필드 검증**: 제목, 재료 정보 존재 여부 확인
- **데이터 품질 검증**: 재료 개수, 조리 단계 완성도 확인
- **일관성 검증**: 데이터 형식 및 구조 일관성 확인

#### 품질 지표
- **완전성**: 필수 정보 포함률
- **정확성**: 데이터 정규화 성공률
- **일관성**: 데이터 형식 통일률

---

## Phase 4: Fridge2Fork 앱 통합 (2-3주)

### 4.1 앱 데이터 모델 매핑

#### Flutter 앱 모델 구조
- **Recipe 모델**: id, name, description, imageUrl, cookingTimeMinutes, servings, difficulty, category, rating, reviewCount, isPopular
- **Ingredient 모델**: name, amount, isEssential
- **CookingStep 모델**: step, description, imageUrl

#### 데이터베이스 → 앱 모델 변환
- **매핑 로직**: 데이터베이스 엔티티를 Flutter 앱 모델로 변환
- **타입 변환**: 데이터베이스 타입을 앱에서 사용하는 타입으로 변환
- **기본값 처리**: 누락된 데이터에 대한 기본값 설정

### 4.2 JSON 변환 시스템

#### 앱용 JSON 생성 전략
- **구조화된 데이터**: 앱에서 사용할 수 있는 형태로 데이터 변환
- **메타데이터 포함**: 버전, 생성일시, 총 레시피 수 등 정보 추가
- **한글 인코딩**: UTF-8 인코딩으로 한글 데이터 보존

#### JSON 구조
- **version**: 데이터 버전 정보
- **generated_at**: 생성 일시
- **total_recipes**: 총 레시피 수
- **recipes**: 레시피 목록 배열

### 4.3 성능 최적화

#### 모바일 앱 성능 고려사항
- **이미지 URL 최적화**: CDN 또는 최적화된 이미지 서버 사용
- **데이터 크기 최적화**: 불필요한 데이터 제거 및 압축
- **페이지네이션 지원**: 대용량 데이터 처리 시 페이지 단위 로딩

#### 페이지네이션 전략
- **페이지 크기**: 20개 레시피 단위로 분할
- **메타데이터**: 페이지 번호, 다음 페이지 존재 여부 포함
- **점진적 로딩**: 앱에서 필요에 따라 페이지별 데이터 로드

---

## Phase 5: 운영 및 유지보수 (지속적)

### 5.1 자동화 시스템 구축

#### 스케줄링 시스템
- **Celery 기반**: 분산 작업 큐 시스템으로 안정적인 작업 스케줄링
- **월간/분기별 실행**: 전체 레시피 수집 작업 자동화
- **신규 레시피 감지**: 변경된 레시피 자동 감지 및 업데이트
- **데이터 검증**: 주간 데이터 품질 검증 및 정리 작업

#### 모니터링 시스템
- **Prometheus 기반**: 실시간 메트릭 수집 및 모니터링
- **주요 지표**: 크롤링된 레시피 수, 오류 발생률, 데이터 품질 점수, 이미지 다운로드 수
- **알림 시스템**: 임계값 초과 시 자동 알림 발송
- **대시보드**: Grafana를 통한 시각적 모니터링

### 5.2 데이터 품질 관리

#### 품질 모니터링 대시보드
- **전체 레시피 수**: 수집된 총 레시피 개수
- **완전한 레시피**: 필수 정보가 모두 포함된 레시피 수
- **이미지 포함 레시피**: 이미지가 있는 레시피 수
- **평균 재료 수**: 레시피당 평균 재료 개수
- **데이터 신선도**: 마지막 업데이트 시간

#### 품질 이슈 관리
- **이미지 없는 레시피**: 중간 심각도 이슈
- **재료 정보 부족**: 높은 심각도 이슈
- **자동 수정**: 자동으로 수정 가능한 이슈 처리
- **수동 검토**: 복잡한 이슈에 대한 수동 검토 프로세스

### 5.3 확장성 고려사항

#### 대규모 처리 지원
- **분산 처리**: 여러 작업자 노드를 통한 병렬 처리
- **Redis 클러스터**: 작업 큐 분산 및 부하 분산
- **동적 확장**: 부하에 따른 자동 스케일링
- **장애 복구**: 노드 장애 시 자동 복구 및 재배치

---

## 📊 예상 일정 및 리소스

### 타임라인
- **Phase 1: 인프라 구축 (2-3주)**
  - 주 1: 기술 스택 선정 및 환경 구축 (Playwright 선택, Docker 환경 구성)
  - 주 2: 데이터베이스 설계 및 구현 (PostgreSQL, 인덱스 최적화)
  - 주 3: 크롤링 시스템 기본 구조 (Raw Python 기반 고속 처리)

- **Phase 2: 데이터 수집 (4-6주)**
  - 주 1-2: 레시피 목록 수집 (200,000+ 개 ID 수집)
  - 주 3-4: 상세 정보 수집 (Playwright 기반 고속 스크래핑)
  - 주 5-6: 이미지 수집 및 처리 (PVC 저장, 최적화)

- **Phase 3: 데이터 정제 (3-4주)**
  - 주 1-2: 재료명 정규화 (표준화 매핑, 분류 체계)
  - 주 3: 조리 단계 정리 (표준화, 이미지 연결)
  - 주 4: 품질 검증 (자동 검증 시스템)

- **Phase 4: 앱 통합 (2-3주)**
  - 주 1-2: 데이터 모델 매핑 (Flutter 앱 호환)
  - 주 3: JSON 생성 및 최적화 (페이지네이션, 성능 최적화)

- **Phase 5: 운영 (지속적)**
  - 자동화 시스템 구축 (Celery, 스케줄링)
  - 모니터링 대시보드 (Prometheus, Grafana)
  - 지속적 개선 (품질 관리, 확장성)

### 필요 리소스
- **개발자**: 2-3명 (백엔드 1명, 데이터 엔지니어 1명, 품질 관리 1명)
- **인프라**: 클라우드 서버 (AWS/GCP), PVC 스토리지
- **기술 스택**: Playwright, PostgreSQL, Redis, Docker
- **모니터링**: Prometheus, Grafana, 로깅 시스템

### 예상 비용
- **개발 비용**: 3-4개월 개발 기간
- **인프라 비용**: 월 $200-500 (서버, PVC, 클라우드 스토리지)
- **유지보수**: 월 $100-200 (모니터링, 백업, 자동화)

---

## ⚠️ 위험 요소 및 대응 방안

### 기술적 위험
1. **웹사이트 구조 변경**
   - 대응: 유연한 셀렉터 시스템, 정기적 구조 분석, Playwright의 안정성 활용
2. **크롤링 차단**
   - 대응: IP 로테이션, User-Agent 변경, 요청 패턴 변경, 1.5초 지연시간 준수
3. **데이터 품질 저하**
   - 대응: 자동 검증 시스템, 수동 검토 프로세스, Raw Python 기반 고속 처리
4. **대용량 데이터 처리**
   - 대응: PostgreSQL 인덱스 최적화, 배치 삽입, 파티셔닝 고려

### 법적 위험
1. **저작권 문제**
   - 대응: robots.txt 준수, 이용약관 확인, 데이터 사용 목적 명시
2. **개인정보 보호**
   - 대응: 개인정보 제외, 익명화 처리, 작성자 정보 최소화

### 운영 위험
1. **서버 부하**
   - 대응: 점진적 확장, 로드 밸런싱, 컨테이너 기반 배치 처리
2. **데이터 손실**
   - 대응: 정기 백업, 복제본 관리, PVC 기반 영구 저장소
3. **배치 처리 실패**
   - 대응: 높은 안정성 우선 설계, 오류 복구 시스템, 월간/분기별 실행

---

## 🎯 성공 지표

### 데이터 품질 지표
- **완전성**: 95% 이상의 레시피가 필수 정보 포함
- **정확성**: 90% 이상의 재료명 정규화 성공
- **일관성**: 95% 이상의 데이터 형식 통일
- **규모**: 200,000+ 개 레시피 수집 완료

### 시스템 성능 지표
- **처리 속도**: Playwright 기반 고속 처리 (Selenium 대비 2-3배 빠름)
- **가용성**: 99.5% 이상 시스템 가동률
- **안정성**: 높은 배치 안정성과 오류 복구
- **확장성**: 분산 처리 및 자동 스케일링 지원

### 앱 통합 지표
- **호환성**: Fridge2Fork 앱과 100% 호환
- **성능**: 앱 로딩 시간 3초 이내
- **사용성**: 사용자 만족도 4.5/5.0 이상
- **데이터 활용**: 냉장고 재료 기반 맞춤 추천 시스템 지원

---

## 📝 결론

이 계획서는 만개의레시피에서 Fridge2Fork 앱으로의 체계적인 데이터 수집 및 통합 프로세스를 제시합니다.

### 핵심 개선사항
- **Playwright 도입**: Selenium 대비 2-3배 빠른 성능으로 대용량 데이터 처리 최적화
- **Raw Python 활용**: ORM 대신 Raw Python으로 대용량 데이터 삽입 속도 향상
- **PVC 저장소**: 클라우드 스토리지 대신 PVC를 통한 비용 효율성 확보
- **배치 처리**: 월간/분기별 전체 수집으로 안정성과 효율성 균형

### 기술적 우위
- **200,000+ 레시피**: 대규모 데이터 수집 및 처리 능력
- **고속 처리**: Playwright + Raw Python 조합으로 최적 성능
- **안정성**: 컨테이너 기반 배치 처리로 높은 안정성 확보
- **확장성**: 분산 처리 및 자동 스케일링으로 미래 확장 대비

각 Phase는 명확한 목표와 산출물을 가지고 있으며, 단계별로 검증과 개선이 가능한 구조로 설계되었습니다. 특히 데이터 품질 관리와 법적 준수사항을 중점적으로 고려하여 안정적이고 확장 가능한 시스템 구축을 목표로 합니다.

성공적인 구현을 통해 Fridge2Fork 앱의 레시피 데이터베이스를 크게 확장하고, 사용자에게 더욱 풍부한 요리 경험을 제공할 수 있을 것입니다.
