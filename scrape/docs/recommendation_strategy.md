### 🎯 **최종 목표**
보유 재료 목록과 가장 유사도가 높은 레시피를 `recipes.json`에서 찾아 추천.

### ⚡ **핵심 과제: 데이터 비정형성**
- **문제점**: 사용자의 재료(예: `소금`)와 레시피의 재료(예: `꽃소금`, `소금•후추`)가 문자열 상으로 정확히 일치하지 않습니다.
- **해결책**: 비교 전에 양쪽 데이터를 모두 **정규화(Normalization)**하여 핵심 재료만 추출해야 합니다.

---

### 💡 **구현 전략 제안: 2-Phase 접근법**

#### **Phase 1: 데이터 정규화 (Data Normalization)**
유사도 비교의 정확도를 높이기 위해, 레시피와 사용자 재료 모두를 동일한 규칙으로 정제합니다.

1.  **기본 정제 (Basic Cleaning)**
    -   **불용어 제거**: `구매`, `약간`, `조금`, `넉넉히` 등 수량/단위와 무관한 단어 제거.
    -   **특수문자 처리**: `•`, `&` 등을 기준으로 문자열 분리 (예: `소금•후추` → `소금`, `후추`).
    -   **수량/단위 제거**: `2개`, `100g`, `1스푼` 등 숫자와 단위 제거.

2.  **핵심 재료 추출 (Keyword Extraction)**
    -   정제된 문자열에서 핵심 명사만 추출합니다. (예: `돼지고기 목살` → `돼지고기`, `목살`).
    -   이를 통해 `다진마늘`과 `마늘`이 동일하게 `마늘`로 인식되도록 기반을 마련합니다.

**정규화 예시:**
`["돼지고기 목살 300g 구매"]` → `['돼지고기', '목살']`

---

#### **Phase 2: 유사도 측정 알고리즘 (Similarity Algorithm)**

정규화된 재료 목록을 기반으로 각 레시피의 "매칭 점수"를 계산합니다.

##### 🏆 **추천 방법: 자카드 지수 (Jaccard Index)**
- **개념**: 두 집합 간의 유사도를 측정하는 가장 보편적이고 효율적인 방법. `(교집합 크기) / (합집합 크기)`
- **계산법**:
    1.  `A` = Set(사용자의 정규화된 재료 목록)
    2.  `B` = Set(레시피의 정규화된 재료 목록)
    3.  `Score = len(A ∩ B) / len(A ∪ B)`
- **장점**:
    -   **효율성**: 내가 가진 재료와 **얼마나 많이 겹치는지**(교집합)를 보면서,
    -   **경제성**: 동시에 내가 **가지지 않은 재료가 얼마나 적은지**(합집합)까지 고려합니다.
    -   결과적으로, 추가 구매 없이 만들 수 있는 가장 이상적인 레시피를 추천합니다.

##### **대안 1: 단순 일치 개수 (Simple Match Count)**
- **개념**: 일치하는 재료의 총 개수로 점수 계산.
- **장점**: 구현이 매우 간단합니다.
- **단점**: 추가로 필요한 재료가 10개인 레시피와 1개인 레시피를 구분하지 못해 비효율적인 추천을 할 수 있습니다.

##### **대안 2: 코사인 유사도 (Cosine Similarity)**
- **개념**: 재료 목록을 벡터로 변환하여 두 벡터 사이의 각도를 계산.
- **장점**: 재료의 출현 빈도까지 고려할 수 있어 더 정교한 추천이 가능합니다.
- **단점**: 구현이 복잡하며, 현재 요구사항에는 자카드 지수만으로도 충분합니다.

---

### 📋 **결론 및 실행 계획**

1.  **1단계 (구현)**: `crawler.py`를 수정하여 `ingredients`를 정규화된 형태(예: `['돼지고기', '목살']`)로 저장하도록 로직을 변경합니다.
2.  **2단계 (추천 로직)**: 사용자의 재료를 입력받아, 1단계와 동일한 방식으로 정규화합니다.
3.  **3단계 (계산)**: `recipes.json`의 모든 레시피를 순회하며 **자카드 지수**를 계산하고, 점수가 가장 높은 레시피를 추천합니다.

이 방법이 가장 정확하고 효율적인 레시피 추천 결과를 제공할 것입니다. 구현을 원하시면 바로 다음 단계를 진행하겠습니다.
